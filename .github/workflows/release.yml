name: Release Automation

on:
  workflow_dispatch:
    inputs:
      version_bump:
        description: 'Type of version bump'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
      custom_version:
        description: 'Custom version (optional, overrides version_bump)'
        required: false
        type: string

env:
  PYTHON_VERSION: "3.12"

jobs:
  create-release-pr:
    name: Create Release PR
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    outputs:
      new_version: ${{ steps.version.outputs.new_version }}
      pr_number: ${{ steps.create_pr.outputs.pr_number }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Set up Python ${{ env.PYTHON_VERSION }}
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Configure git
      run: |
        git config --global user.name "github-actions[bot]"
        git config --global user.email "github-actions[bot]@users.noreply.github.com"

    - name: Calculate new version
      id: version
      run: |
        # Get current version
        CURRENT_VERSION=$(python -c "
        try:
            import tomllib
        except ImportError:
            import tomli as tomllib
        with open('pyproject.toml', 'rb') as f:
            data = tomllib.load(f)
        print(data['project']['version'])
        ")
        echo "Current version: $CURRENT_VERSION"

        # Calculate new version
        if [ -n "${{ github.event.inputs.custom_version }}" ]; then
          NEW_VERSION="${{ github.event.inputs.custom_version }}"
          echo "Using custom version: $NEW_VERSION"
        else
          NEW_VERSION=$(python -c "
        current = '$CURRENT_VERSION'
        bump_type = '${{ github.event.inputs.version_bump }}'

        # Simple semantic versioning without external dependencies
        parts = current.split('.')
        major, minor, patch = int(parts[0]), int(parts[1]), int(parts[2])

        if bump_type == 'patch':
            patch += 1
        elif bump_type == 'minor':
            minor += 1
            patch = 0
        elif bump_type == 'major':
            major += 1
            minor = 0
            patch = 0
        else:
            raise ValueError(f'Invalid bump type: {bump_type}')

        print(f'{major}.{minor}.{patch}')
        ")
          echo "Calculated new version: $NEW_VERSION"
        fi

        echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT

    - name: Create release branch
      run: |
        BRANCH_NAME="release/v${{ steps.version.outputs.new_version }}"
        git checkout -b "$BRANCH_NAME"
        echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV

    - name: Update version in files
      run: |
        NEW_VERSION="${{ steps.version.outputs.new_version }}"

        # Update pyproject.toml
        python -c "
        import re
        new_version = '$NEW_VERSION'

        with open('pyproject.toml', 'r') as f:
            content = f.read()

        content = re.sub(
            r'^version = \".*\"',
            f'version = \"{new_version}\"',
            content,
            flags=re.MULTILINE
        )

        with open('pyproject.toml', 'w') as f:
            f.write(content)
        "

        # Update manifest.json
        python -c "
        import json
        new_version = '$NEW_VERSION'

        with open('custom_components/wrtmanager/manifest.json', 'r') as f:
            manifest = json.load(f)

        manifest['version'] = new_version

        with open('custom_components/wrtmanager/manifest.json', 'w') as f:
            json.dump(manifest, f, indent=2)
            f.write('\n')
        "

    - name: Commit changes
      run: |
        git add pyproject.toml custom_components/wrtmanager/manifest.json
        git commit --no-verify -m "Bump version to ${{ steps.version.outputs.new_version }}"

    - name: Push release branch
      run: |
        git push origin "$BRANCH_NAME"

    - name: Create Pull Request
      id: create_pr
      run: |
        PR_BODY="üöÄ **Release v${{ steps.version.outputs.new_version }}**

        This PR bumps the version to \`${{ steps.version.outputs.new_version }}\` and prepares for release.

        ## Changes
        - ‚¨ÜÔ∏è Version bump: \`${{ steps.version.outputs.new_version }}\`
        - üìù Updated \`pyproject.toml\`
        - üìù Updated \`manifest.json\`

        ## Release Checklist
        - [ ] CI/CD pipeline passes
        - [ ] Version consistency verified
        - [ ] Ready for release

        Auto-generated by Release Automation workflow."

        # Create PR using gh CLI
        PR_URL=$(gh pr create \
          --title "üöÄ Release v${{ steps.version.outputs.new_version }}" \
          --body "$PR_BODY" \
          --base main \
          --head "$BRANCH_NAME")

        # Extract PR number from URL
        PR_NUMBER=$(echo "$PR_URL" | grep -o '[0-9]\+$')
        echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
        echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT
        echo "‚úÖ Created PR: $PR_URL"
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  create-github-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    needs: create-release-pr
    # Only run this job when the PR is merged to main
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Create Git Tag
      run: |
        NEW_VERSION="${{ needs.create-release-pr.outputs.new_version }}"
        git config --global user.name "github-actions[bot]"
        git config --global user.email "github-actions[bot]@users.noreply.github.com"

        git tag -a "v$NEW_VERSION" -m "Release v$NEW_VERSION"
        git push origin "v$NEW_VERSION"

    - name: Generate changelog
      id: changelog
      run: |
        # Get the previous tag for changelog generation
        PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo "")
        NEW_VERSION="${{ needs.create-release-pr.outputs.new_version }}"

        if [ -z "$PREVIOUS_TAG" ]; then
          echo "## What's Changed" > changelog.md
          echo "" >> changelog.md
          echo "Initial release of WRT Manager Home Assistant Integration v$NEW_VERSION" >> changelog.md
        else
          echo "## What's Changed" > changelog.md
          echo "" >> changelog.md
          git log --oneline --pretty=format:"- %s" $PREVIOUS_TAG..HEAD >> changelog.md
        fi

        echo "" >> changelog.md
        echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/${PREVIOUS_TAG}...v${NEW_VERSION}" >> changelog.md

        # Output for use in release
        {
          echo 'CHANGELOG<<EOF'
          cat changelog.md
          echo EOF
        } >> $GITHUB_OUTPUT

    - name: Create GitHub Release
      run: |
        NEW_VERSION="${{ needs.create-release-pr.outputs.new_version }}"

        gh release create "v$NEW_VERSION" \
          --title "üöÄ WRT Manager v$NEW_VERSION" \
          --notes "${{ steps.changelog.outputs.CHANGELOG }}" \
          --latest
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Comment on PR
      if: always()
      run: |
        NEW_VERSION="${{ needs.create-release-pr.outputs.new_version }}"
        PR_NUMBER="${{ needs.create-release-pr.outputs.pr_number }}"

        if [ "${{ job.status }}" = "success" ]; then
          COMMENT="üéâ **Release v$NEW_VERSION has been successfully created!**

          ‚úÖ Git tag \`v$NEW_VERSION\` created
          ‚úÖ GitHub release published
          üì¶ Release: https://github.com/${{ github.repository }}/releases/tag/v$NEW_VERSION"
        else
          COMMENT="‚ùå **Release creation failed for v$NEW_VERSION**

          Please check the workflow logs for details."
        fi

        gh pr comment "$PR_NUMBER" --body "$COMMENT"
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}